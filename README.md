ml-final gkuch22 lsurm22


xgboost
გადავწყვიტე ნაცნობი მოდელით დამეწყო ამ ჩელენჯის დამუშავება. პირველ გაშვებაზე უბრალოდ ავიღე train.csv მხოლოდ სხვა მონაცემებთან გაერთიანების გარეშე, დავსორტე დატა დროის მიხედვით და ისე გავყავი train valid test სეტებად და default ჰიპერპარამეტრებით გავუშვი xgboost რომ მენახა რა შედეგი დაიდებოდა weighted mae ზე. 8600 8100 არის საწყისი წერტილი მოდელის გაუმჯობესებამდე. შემდეგ ჯერზე გადავწყვიტე სხვა მონაცმეებიც გამომეყენებინა. ამიტო stores და features სეტები დავმერჯე train თან. აქ features ში დროის მხრივ უფრო გვიანდელი მონაცემები გვაქვს 2013 წლის რაც train ში არ ხდება თუმცა ამას შემდეგ მივხედავთ, ჯერჯერობით left merge ამ ნაწილს არ გადააბამს. შედეგად მივიღე 15 სვეტიანი თეიბლი. კატეგორიული სვეტები მარტო type გვხვდება ამიტო ჯერჯერობით OrdinalEncoder ით გადავაკეთე რიცხვებში. ხოლო Nan ველიეუები SimpleImputer ის გამოყენებით mean ით შევავსე. ასევე Date სვეტი გავხლიჩე და year month week სამი ახალი ფიჩერი მივიღე. საწყისი Date ცვლადის სხვა რაიმე რიცხით წარმოდგენას ასე დაყოფა ვამჯობინე, რადგან ვფიქრობ უკეთ მიხვდება მოდელი დროის მხრივ sales ის მიხვედრას. რაც შეეხება სპლიტს, დატა როგორც ვთქვი დავსორტე და იმისთვის რომ რენდომად არ გადალაგებულიყო როუები, year_split month_split threshold ები შემოვიღე რის მიხედვითაც დავყავი დატა სამ ნაწილად. ჯერჯერობით 2012 წლამდე მონაცემები train ში გავანაწილე და შემდეგ 2012 ის მონაცმები თანაბრად გავყავი valid და test სეტებში. xgboost ის ჰიპერპარამეტრები იგივე დავტოვე წინა გაშვებიდან, შედეგი გაუმჯობესდა 7290 6990 ერორმა დაახლოებით 1200 ით დაიკლო წინა გაშვებიდან, ანუ features და stores დატასეტები მნიშვნელოვან ინფორმაციას შეიცვადნენ მოდელზე დასახმრებლად. ასევე დავპლოტე feature importance ები და ვხედავ, რომ dept, size, store ს ყველაზე დიდი მნიშვნელობა ენიჭება მოდელისგან. შემდეგ გაშვებაზე type-ს onehot encoder ით გარდავქმნი ორდინალის მაგივრად, ასევე საშუალოდ სეილების ავარდნაზე დაკვირვებით დავინახე რომ ახალწლამდე დიდი სპაიკები გვაქვს, ამიტო გადავწყვიტე დატაში WeeksToNewYear სვეტი ჩამემატებინა, რომელიც 1 2 3 კვირით ადრე კვირებს მოუნიშნავს მოდელს და ასევე დროის აღქმას გაუუმჯობესებს წესით. 7135 6833 შედეგი გაუმჯობესდა. weekstonewyear სვეტს ნორმალური importance მიენიჭა. ამის შემდეგ დავაკვირდი რომ holiday ს დროს თითოეული store სხვადასხვანაირად რეაგირებდა sales-ს მხრივ. ამიტომ დავამატე StoreHolidayLift სვეტი, ამით მოდელს ვეხმარები რომ უბრალოდ isHoliday true ან false ის მაგრივრად დამატებით წარმოდგენა შეექმნას საშუალოდ როგორი ავარდნა ხდება holiday ს დროს თითოეულ store ში. ამან შედეგი ოდნავ გააუარესა 7280 7090 მაგრამ StoreHolidayLift importance ში მეორე ადგილი დაიკავა, ამიტომ ეს საჭირო სვეტად ჩავთვალე და სხვა ფიჩერებთან ერთად უკეთეს შედეგს მოგვცემს წესით ბოლოს. იგივე პრინციპით გადავწყვიტე თითოეულ დეპარტამენტზეც განმესაზღვრა რამდენად ხდება sales ის ცვლილება. დავამატე DeptHolidayLift სვეტი. მივიღე ჯერჯეორბით საუკეთესო შედეგი 6700 6600. საკმაოდ დიდი importance მიენიჭა ამ სვეტს, როგორც ვთქვი StoreHolidayLift-ს სხვა ფიჩერთან ერთად კარგი გავლენა ჰქონდა მოდელზე. ამის შემდეგ ახალ წლამდე კვირების დამატების მსგავსად, რამდენიმე კონკრეტულ store department წყვილს დავაკვირდი, როგორ წესი spike-მდე ხშირად შემხვდა isHoliday=True შემთხვევა, ასევე სპაიკის შემდეგაც იყო ხოლმე ჰოლიდეი, ამიტომ გადავწყვიტე დამემატებინა სვეტები, რომლებიც აღნიშნავენ იყო თუ არა წინა და იმის წინა კვირები ჰოლიდეი და იქნება თუ არა შემდეგი და იმის შემდეგი კვირები ჰოლიდეი. ეს წესით დაახლოებით წარმოდგენას შუქმნის მოდელს როდის უნდა ელოდოს დიდ ვარდნას. მცირე მაგრამ მაინც შედარებით უკეთესი შედეგი მომცა ამან. ამის შემდეგ იგივე ლოგიკით დავამატე წინა კვირების შესაბმისი sale-ები რომ დროის მხრივ როგორ ხდება ხოლმე ზრდ-მატება ისწავლოს მოდელმა, ამან ძალიან კარგი შედეგი დადო. 2420 2370 სქორი და წინა 1 2 4 კვირის სვეტებმა feature importance ში ტოპ 5 ადგილი დაიკავა. feature engineering ის ნაწილში ვფიქრობ ამ მოდელისთვის მეტის დამატება აღარაა საჭირო, ახლა grid search გავუშვი რომ თვითონ xgboost ის ჰაიპერპარამეტრები დამეტუნინგებინა. 1100 1900 საკმაოდ კარგი wmae სქორი მივიღე.





